<!DOCTYPE html>
<html lang="en-us">

<head>
  <meta charset="utf-8">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Unity Web Player | JuiciosOralesMultiplayerv1.0</title>
  <!-- CSS inline para evitar dependencia de TemplateData/style.css -->
  <style>
    /* Estilos b√°sicos de Unity WebGL */
    body { margin: 0; padding: 0; background: #000; font-family: Arial, sans-serif; }
    #unity-container { width: 100vw; height: 100vh; }
    #unity-canvas { width: 100%; height: 100%; display: block; }
    #unity-loading-bar { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); }
    #unity-warning { position: absolute; left: 50%; top: 5%; transform: translate(-50%, 0); background: rgba(0, 0, 0, 0.8); color: #ffcccc; padding: 5px 10px; border-radius: 5px; display: none; }
    
    /* Ventana de Logs de Debug */
    #debug-log-window {
      position: fixed;
      bottom: 10px;
      left: 10px;
      width: 600px;
      max-height: 500px;
      background: rgba(20, 20, 20, 0.95);
      border: 2px solid #4CAF50;
      border-radius: 8px;
      z-index: 100000;
      display: flex;
      flex-direction: column;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      font-family: 'Courier New', monospace;
      font-size: 11px;
    }
    
    #debug-log-header {
      background: #2d2d2d;
      padding: 8px 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #4CAF50;
      cursor: move;
      user-select: none;
    }
    
    #debug-log-title {
      color: #4CAF50;
      font-weight: bold;
      font-size: 12px;
    }
    
    #debug-log-controls {
      display: flex;
      gap: 5px;
    }
    
    .debug-log-btn {
      background: #444;
      border: 1px solid #666;
      color: #fff;
      padding: 4px 8px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 10px;
    }
    
    .debug-log-btn:hover {
      background: #555;
    }
    
    #debug-log-content {
      flex: 1;
      overflow-y: auto;
      padding: 8px;
      color: #e0e0e0;
      max-height: 450px;
    }
    
    .debug-log-entry {
      margin: 2px 0;
      padding: 2px 4px;
      border-left: 2px solid transparent;
      word-wrap: break-word;
      white-space: pre-wrap;
    }
    
    .debug-log-entry.debug { border-left-color: #888; color: #aaa; }
    .debug-log-entry.info { border-left-color: #2196F3; color: #90caf9; }
    .debug-log-entry.warning { border-left-color: #ff9800; color: #ffb74d; }
    .debug-log-entry.error { border-left-color: #f44336; color: #ef5350; }
    .debug-log-entry.phase { border-left-color: #4CAF50; color: #81c784; font-weight: bold; }
    .debug-log-entry.api { border-left-color: #9c27b0; color: #ba68c8; }
    .debug-log-entry.event { border-left-color: #00bcd4; color: #4dd0e1; }
    
    .debug-log-entry .timestamp {
      color: #666;
      margin-right: 5px;
    }
    
    .debug-log-entry .category {
      color: #888;
      margin-right: 5px;
      font-weight: bold;
    }
    
    #debug-log-window.minimized {
      height: auto;
      max-height: 40px;
    }
    
    #debug-log-window.minimized #debug-log-content {
      display: none;
    }
    
    #debug-log-content::-webkit-scrollbar {
      width: 8px;
    }
    
    #debug-log-content::-webkit-scrollbar-track {
      background: #1a1a1a;
    }
    
    #debug-log-content::-webkit-scrollbar-thumb {
      background: #4CAF50;
      border-radius: 4px;
    }
    
    #debug-log-content::-webkit-scrollbar-thumb:hover {
      background: #66bb6a;
    }
  </style>
  <script src="https://unpkg.com/peerjs@1.5.5/dist/peerjs.min.js"></script>
  <style>
    .audio-status-container {
      position: absolute;
      top: 10px;
      right: 10px;
      display: flex;
      gap: 10px;
      z-index: 9999
    }

    .audio-card {
      width: 60px;
      height: 60px;
      border-radius: 10px;
      background-color: #ccc;
      display: flex;
      justify-content: center;
      align-items: center;
      transition: background-color .3s
    }

    .audio-card.active {
      background-color: #4CAF50
    }

    .audio-card img {
      width: 32px;
      height: 32px;
      filter: invert(1)
    }
  </style>
</head>

<body>
  <!-- Ventana de Logs de Debug -->
  <div id="debug-log-window">
    <div id="debug-log-header">
      <div id="debug-log-title">üìã DEBUG LOGS</div>
      <div id="debug-log-controls">
        <button class="debug-log-btn" onclick="clearDebugLogs()">Limpiar</button>
        <button class="debug-log-btn" onclick="toggleDebugLogWindow()">Minimizar</button>
        <button class="debug-log-btn" onclick="toggleDebugLogEnabled()" id="toggle-log-btn">Desactivar</button>
      </div>
    </div>
    <div id="debug-log-content"></div>
  </div>

  <div class="audio-status-container">
    <div id="micCard" class="audio-card" title="Emitiendo">
      <img src="https://img.icons8.com/ios-filled/50/microphone.png" />
    </div>
    <div id="speakerCard" class="audio-card" title="Recibiendo">
      <img src="https://img.icons8.com/ios-filled/50/speaker.png" />
    </div>
  </div>

  <!-- Panel de Debug para Testing -->
  <div id="debug-panel"
    style="position: absolute; top: 80px; right: 10px; background: rgba(0,0,0,0.8); color: white; padding: 10px; border-radius: 5px; font-family: monospace; font-size: 12px; z-index: 10000; min-width: 200px; display: none;">
    <div style="font-weight: bold; margin-bottom: 5px; color: #4CAF50;">üîß DEBUG PANEL</div>
    <div>Mi ID: <span id="my-id">-</span></div>
    <div>Conexiones: <span id="connections-count">0</span></div>
    <div>Streams activos: <span id="streams-count">0</span></div>
    <div>Estado Peer: <span id="peer-status">-</span></div>
    <div>Latencia: <span id="latency">-</span></div>
    <div style="margin-top: 10px;">
      <button id="debug-toggle"
        style="background: #4CAF50; border: none; color: white; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-right: 5px;">Ocultar</button>
      <button id="debug-reset"
        style="background: #f44336; border: none; color: white; padding: 5px 10px; border-radius: 3px; cursor: pointer;">Reset</button>
    </div>
  </div>

  <div id="unity-container" class="unity-desktop">
    <canvas id="unity-canvas" width="960" height="600" tabindex="-1"></canvas>
    <div id="unity-loading-bar">
      <div id="unity-logo"></div>
      <div id="unity-progress-bar-empty">
        <div id="unity-progress-bar-full"></div>
      </div>
    </div>
    <div id="unity-warning"></div>
    <div id="unity-footer">
      <div id="unity-logo-title-footer"></div>
      <div id="unity-fullscreen-button"></div>
      <div id="unity-build-title">JuiciosOralesMultiplayerv1.0</div>
    </div>
  </div>

  <script>
    let peer = null, localStream = null, myId = null, connections = {}, roomId = null, dialInterval = null;
    const MAX_SLOTS = 20; // <- 20 espacios por sala

    // Funci√≥n original para compatibilidad (llama a initVoiceCallFromUnity con configuraci√≥n por defecto)
    window.initVoiceCall = async function(_roomId, actorId) {
      console.log("Init Voice Call (compatibilidad):", _roomId, actorId);
      // Llamar a la nueva funci√≥n con configuraci√≥n por defecto (JSON vac√≠o)
      return window.initVoiceCallFromUnity(_roomId, actorId, '{}');
    };

    // Funci√≥n para inicializar PeerJS desde Unity con configuraci√≥n personalizada
    window.initVoiceCallFromUnity = async function(_roomId, actorId, configJson) {
      console.log("Init Voice Call from Unity:", _roomId, actorId, configJson);
      roomId = _roomId; myId = `${roomId}_${actorId}`;
      
      // Parsear configuraci√≥n desde Unity
      let unityConfig = null;
      try {
        unityConfig = JSON.parse(configJson);
      } catch (e) {
        console.warn("No se pudo parsear configuraci√≥n de Unity, usando valores por defecto");
      }
      
      // Configuraci√≥n de audio desde Unity o valores por defecto
      const audioConfig = unityConfig?.audio || {
        echoCancellation: true,
        noiseSuppression: true,
        autoGainControl: true,
        sampleRate: 44100,
        channelCount: 1,
        latency: 0.01
      };
      
      try {
        localStream = await navigator.mediaDevices.getUserMedia({
          audio: audioConfig
        });
        activarIndicadorVolumen(localStream, document.getElementById("micCard"));
      } catch (err) { 
        alert("No se pudo acceder al micr√≥fono."); 
        console.error(err); 
        // Notificar error a Unity
        if (window.unityInstance) {
          window.unityInstance.SendMessage('PeerJSManager', 'OnPeerJSErrorCallback', err.message);
        }
        return; 
      }

      // Configuraci√≥n de servidores PeerJS desde Unity o valores por defecto
      const primaryConfig = unityConfig ? {
        host: unityConfig.host || 'peerjs.com',
        port: unityConfig.port || 443,
        secure: unityConfig.secure !== undefined ? unityConfig.secure : true,
        path: unityConfig.path || '/peerjs',
        debug: 2
      } : null;
      
      const peerConfigs = primaryConfig ? [primaryConfig] : [
        {
          host: 'localhost',
          port: 9000,
          secure: false,
          path: '/peerjs',
          debug: 2
        },
        {
          host: 'peerjs.com',
          port: 443,
          secure: true,
          path: '/peerjs',
          debug: 2
        },
        {
          host: '0.peerjs.com',
          port: 443,
          secure: true,
          path: '/peerjs',
          debug: 2
        },
        {
          host: '1.peerjs.com',
          port: 443,
          secure: true,
          path: '/peerjs',
          debug: 2
        }
      ];

      let currentConfigIndex = 0;

      function tryNextPeerConfig() {
        if (currentConfigIndex >= peerConfigs.length) {
          console.error('‚ùå Todos los servidores PeerJS fallaron');
          return null;
        }

        const config = peerConfigs[currentConfigIndex];
        console.log(`üîÑ Intentando servidor PeerJS ${currentConfigIndex + 1}/${peerConfigs.length}:`, config.host);

        return new Peer(myId, {
          ...config,
          config: {
            iceServers: [
              { urls: 'stun:stun.l.google.com:19302' },
              { urls: 'stun:stun1.l.google.com:19302' },
              { urls: 'stun:stun2.l.google.com:19302' }
            ],
            iceTransportPolicy: 'all'
          }
        });
      }

      peer = tryNextPeerConfig();

      if (peer) {
        setupPeerEvents(peer);
      }
    };

    function setupPeerEvents(peerInstance) {
      peerInstance.on('open', id => {
        console.log("PeerJS abierto con ID:", id);

        // Funci√≥n mejorada para notificar a Unity
        const notifyUnity = () => {
          try {
            if (window.unityInstance) {
              // Intentar notificar a PeerJSManager primero (nuevo sistema)
              try {
                window.unityInstance.SendMessage('PeerJSManager', 'OnPeerJSReadyCallback', id);
                console.log("‚úÖ Notificaci√≥n enviada a PeerJSManager:", id);
                return true;
              } catch (e) {
                // Si no existe PeerJSManager, intentar con GestionRedJugador (compatibilidad)
                try {
                  window.unityInstance.SendMessage('GestionRedJugador', 'OnVoiceReady', id);
                  console.log("‚úÖ Notificaci√≥n enviada a GestionRedJugador:", id);
                  return true;
                } catch (e2) {
                  console.log("‚ö†Ô∏è No se encontr√≥ PeerJSManager ni GestionRedJugador, reintentando...");
                  return false;
                }
              }
            }
          } catch (e) {
            console.log("‚ö†Ô∏è Error al comunicar con Unity:", e.message);
          }
          return false;
        };

        // Reintentar hasta 20 veces (10 segundos)
        let tries = 0;
        const retryInterval = setInterval(() => {
          if (notifyUnity() || ++tries > 20) {
            clearInterval(retryInterval);
            if (tries > 20) {
              console.warn("‚ö†Ô∏è No se pudo comunicar con Unity despu√©s de 20 intentos");
            }
          }
        }, 500);

        startAutoDial();
      });

      peerInstance.on('call', call => {
        console.log("üìû Llamada entrante de:", call.peer);
        addDiscoveredPeer(call.peer); // Marcar como descubierto

        call.answer(localStream);
        call.on('stream', rs => {
          console.log("‚úÖ Stream entrante de:", call.peer);
          playStream(rs, call.peer);
        });
        call.on('close', () => {
          console.log("‚ùå Llamada cerrada por:", call.peer);
          cleanupPeer(call.peer);
          discoveredPeers.delete(call.peer);
        });
        call.on('error', e => {
          console.warn('üö® Error en llamada entrante de', call.peer, ':', e);
        });
        connections[call.peer] = call;
      });

      peerInstance.on('error', err => {
        console.error('üö® Error de PeerJS:', err);

        // Si es un error de conexi√≥n al servidor, intentar con el siguiente
        if (err.message && (
          err.message.includes('Lost connection to server') ||
          err.message.includes('bad response from the server') ||
          err.message.includes('WebSocket connection') ||
          err.message.includes('Connection failed')
        )) {
          console.log('üîÑ Error de servidor detectado, intentando con el siguiente...');
          currentConfigIndex++;

          // Cerrar conexi√≥n actual
          if (peerInstance) {
            peerInstance.destroy();
          }

          // Intentar con el siguiente servidor
          setTimeout(() => {
            peer = tryNextPeerConfig();
            if (peer) {
              setupPeerEvents(peer);
            }
          }, 2000);
        } else if (err.message && err.message.includes('Could not connect')) {
          console.log('‚ÑπÔ∏è PeerJS: Conexi√≥n no disponible (normal en testing)');
        }
      });

      peerInstance.on('disconnected', () => {
        console.warn('Peer desconectado');
        // Intentar reconectar autom√°ticamente
        setTimeout(() => {
          if (currentConfigIndex < peerConfigs.length) {
            console.log('üîÑ Intentando reconectar...');
            peer = tryNextPeerConfig();
            if (peer) {
              setupPeerEvents(peer);
            }
          }
        }, 3000);
      });

      peerInstance.on('close', () => console.warn('Peer cerrado'));
    }

    function callPeer(peerId) {
      if (!peer || peerId === myId || connections[peerId]) return;

      console.log("üîä Llamando a:", peerId);
      const call = peer.call(peerId, localStream);
      if (!call) return;

      call.on('stream', rs => {
        console.log("‚úÖ Audio recibido de:", peerId);
        addDiscoveredPeer(peerId); // Marcar como descubierto
        playStream(rs, peerId);
        
        // Notificar a Unity
        if (window.unityInstance) {
          try {
            window.unityInstance.SendMessage('PeerJSManager', 'OnPeerConnectedCallback', peerId);
          } catch (e) {
            // Ignorar si no existe PeerJSManager
          }
        }
      });

      call.on('close', () => {
        console.log("‚ùå Conexi√≥n cerrada con:", peerId);
        cleanupPeer(peerId);
        discoveredPeers.delete(peerId); // Remover de descubiertos
        
        // Notificar a Unity
        if (window.unityInstance) {
          try {
            window.unityInstance.SendMessage('PeerJSManager', 'OnPeerDisconnectedCallback', peerId);
          } catch (e) {
            // Ignorar si no existe PeerJSManager
          }
        }
      });

      call.on('error', e => {
        // Solo mostrar errores importantes, no "Could not connect" que son normales
        if (!e.message || !e.message.includes('Could not connect')) {
          console.error("üö® Error en llamada con", peerId, ":", e);
        } else {
          console.log("‚ÑπÔ∏è No se pudo conectar con", peerId, "(normal si no hay usuario)");
        }
      });

      connections[peerId] = call;
    }
    window.callPeerFromUnity = callPeer;

    function cleanupPeer(peerId) {
      const c = connections[peerId];
      if (c) { try { c.close(); } catch { } delete connections[peerId]; }
      const el = document.getElementById('audio-' + peerId); if (el) el.remove();
    }
    window.cleanupPeer = cleanupPeer; // Hacer disponible globalmente para Unity
    
    // Funci√≥n para limpiar todas las conexiones
    window.cleanupAllPeers = function() {
      console.log("üßπ Limpiando todas las conexiones PeerJS");
      for (const peerId in connections) {
        cleanupPeer(peerId);
      }
      if (peer) {
        try {
          peer.destroy();
        } catch (e) {
          console.warn("Error al destruir peer:", e);
        }
        peer = null;
      }
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }
      if (dialInterval) {
        clearInterval(dialInterval);
        dialInterval = null;
      }
      roomId = null;
      myId = null;
      console.log("‚úÖ Todas las conexiones limpiadas");
    };

    function startAutoDial() {
      if (dialInterval) clearInterval(dialInterval);
      if (discoveryInterval) clearInterval(discoveryInterval);

      // B√∫squeda inicial
      dialRoomPeersOnce();

      // B√∫squeda peri√≥dica cada 3 segundos
      dialInterval = setInterval(dialRoomPeersOnce, 3000);

      // Limpieza de peers descubiertos cada 10 segundos
      discoveryInterval = setInterval(cleanupDiscoveredPeers, 10000);
    }

    function stopAutoDial() {
      if (dialInterval) {
        clearInterval(dialInterval);
        dialInterval = null;
      }
      if (discoveryInterval) {
        clearInterval(discoveryInterval);
        discoveryInterval = null;
      }
    }

    // Sistema inteligente de descubrimiento de usuarios
    let discoveredPeers = new Set(); // Almacenar peers descubiertos
    let discoveryInterval = null;

    function dialRoomPeersOnce() {
      if (!peer || peer.disconnected || !roomId) return;

      console.log("üîç Buscando usuarios en la sala...");

      // Solo intentar conectar con peers que sabemos que existen
      // o con un rango limitado para testing
      const maxSlots = 10; // Reducir a 10 slots m√°ximo

      for (let i = 1; i <= maxSlots; i++) {
        const pid = `${roomId}_${i}`;
        if (pid !== myId && !connections[pid] && !discoveredPeers.has(pid)) {
          // Solo intentar conectar si no hemos fallado recientemente
          callPeer(pid);
        }
      }
    }

    // Funci√≥n para agregar peer descubierto
    function addDiscoveredPeer(peerId) {
      discoveredPeers.add(peerId);
      console.log("‚úÖ Peer descubierto:", peerId);
    }

    // Funci√≥n para limpiar peers no disponibles
    function cleanupDiscoveredPeers() {
      const activePeers = new Set(Object.keys(connections));
      const toRemove = [];

      discoveredPeers.forEach(peerId => {
        if (!activePeers.has(peerId)) {
          toRemove.push(peerId);
        }
      });

      toRemove.forEach(peerId => {
        discoveredPeers.delete(peerId);
        console.log("üßπ Peer removido de descubiertos:", peerId);
      });
    }

    // Funci√≥n para obtener estad√≠sticas de descubrimiento
    function getDiscoveryStats() {
      return {
        discoveredPeers: Array.from(discoveredPeers),
        activeConnections: Object.keys(connections),
        totalDiscovered: discoveredPeers.size,
        activeCount: Object.keys(connections).length
      };
    }

    // Funci√≥n para forzar b√∫squeda de peers espec√≠ficos
    function searchForPeers(peerIds) {
      console.log("üîç B√∫squeda dirigida de peers:", peerIds);
      peerIds.forEach(peerId => {
        if (peerId !== myId && !connections[peerId]) {
          callPeer(peerId);
        }
      });
    }

    function playStream(stream, peerId) {
      let audio = document.getElementById('audio-' + peerId);
      if (!audio) {
        console.log("üéµ Creando elemento de audio para:", peerId);
        audio = document.createElement('audio');
        audio.id = 'audio-' + peerId;
        audio.autoplay = true;
        audio.playsInline = true;
        audio.style.display = 'none';
        audio.volume = 1.0; // Volumen m√°ximo
        audio.muted = false; // Asegurar que no est√© silenciado

        // Eventos para debugging
        audio.addEventListener('loadedmetadata', () => {
          console.log("‚úÖ Audio metadata cargado para:", peerId);
        });

        audio.addEventListener('canplay', () => {
          console.log("‚úÖ Audio listo para reproducir:", peerId);
          audio.play().catch(e => console.log("‚ö†Ô∏è Error al reproducir:", e));
        });

        audio.addEventListener('error', (e) => {
          console.error("‚ùå Error en audio:", peerId, e);
        });

        document.body.appendChild(audio);
      }
      audio.srcObject = stream;
      console.log("üîä Reproduciendo audio de:", peerId);
      activarIndicadorVolumen(stream, document.getElementById("speakerCard"));
    }

    function activarIndicadorVolumen(stream, cardElement) {
      const AC = window.AudioContext || window.webkitAudioContext;
      const ctx = new AC(); const src = ctx.createMediaStreamSource(stream); const an = ctx.createAnalyser();
      an.fftSize = 1024; const buf = new Uint8Array(an.frequencyBinCount); src.connect(an);
      (function upd() { an.getByteFrequencyData(buf); const v = buf.reduce((a, b) => a + b, 0) / buf.length; cardElement.classList.toggle("active", v > 10); requestAnimationFrame(upd); })();
    }

    // ===== HERRAMIENTAS DE TESTING Y DEBUGGING =====

    // Variables para debugging
    let debugInterval = null;
    let latencyMeasurements = [];

    // Funci√≥n para actualizar el panel de debug
    function updateDebugPanel() {
      const myIdElement = document.getElementById('my-id');
      const connectionsElement = document.getElementById('connections-count');
      const streamsElement = document.getElementById('streams-count');
      const peerStatusElement = document.getElementById('peer-status');
      const latencyElement = document.getElementById('latency');

      if (myIdElement) myIdElement.textContent = myId || '-';
      if (connectionsElement) connectionsElement.textContent = Object.keys(connections).length;
      if (streamsElement) streamsElement.textContent = document.querySelectorAll('audio').length;

      let peerStatus = 'No inicializado';
      if (peer) {
        if (peer.disconnected) peerStatus = 'Desconectado';
        else if (peer.open) peerStatus = 'Conectado';
        else peerStatus = 'Conectando...';
      }
      if (peerStatusElement) peerStatusElement.textContent = peerStatus;

      // Calcular latencia promedio
      if (latencyMeasurements.length > 0) {
        const avgLatency = latencyMeasurements.reduce((a, b) => a + b, 0) / latencyMeasurements.length;
        if (latencyElement) latencyElement.textContent = `${avgLatency.toFixed(0)}ms`;
      } else {
        if (latencyElement) latencyElement.textContent = '-';
      }
    }

    // Funci√≥n para medir latencia de audio
    function measureAudioLatency() {
      const audioElements = document.querySelectorAll('audio');
      let activeStreams = 0;
      let totalLatency = 0;

      audioElements.forEach(audio => {
        if (audio.srcObject) {
          activeStreams++;
          const startTime = performance.now();
          audio.addEventListener('loadeddata', () => {
            const latency = performance.now() - startTime;
            latencyMeasurements.push(latency);
            // Mantener solo las √∫ltimas 10 mediciones
            if (latencyMeasurements.length > 10) {
              latencyMeasurements.shift();
            }
          }, { once: true });
        }
      });

      if (activeStreams > 0) {
        console.log(`üìä Audio: ${activeStreams} streams activos`);
      }
    }

    // Funci√≥n para iniciar debugging
    function startDebugging() {
      const debugPanel = document.getElementById('debug-panel');
      if (debugPanel) {
        debugPanel.style.display = 'block';
        debugInterval = setInterval(() => {
          updateDebugPanel();
          measureAudioLatency();
        }, 1000);
        console.log('üîß Panel de debug activado');
      }
    }

    // Funci√≥n para detener debugging
    function stopDebugging() {
      const debugPanel = document.getElementById('debug-panel');
      if (debugPanel) {
        debugPanel.style.display = 'none';
      }
      if (debugInterval) {
        clearInterval(debugInterval);
        debugInterval = null;
      }
      console.log('üîß Panel de debug desactivado');
    }

    // Funci√≥n para resetear conexiones
    function resetConnections() {
      Object.keys(connections).forEach(peerId => {
        console.log(`üßπ Limpiando conexi√≥n: ${peerId}`);
        cleanupPeer(peerId);
      });
      latencyMeasurements = [];
      console.log('üßπ Todas las conexiones han sido limpiadas');
    }

    // Funci√≥n para testing (servidor y local)
    function enableTesting() {
      // Activar en cualquier entorno para testing
      console.log('üß™ MODO TESTING ACTIVADO');
      console.log('üìã Para testing:');
      console.log('   1. Abre esta p√°gina en 2-3 pesta√±as diferentes');
      console.log('   2. √önete a la misma sala desde cada pesta√±a');
      console.log('   3. Usa testAudio.status() en la consola para ver el estado');
      console.log('   4. Usa testAudio.diagnose() para verificar Unity');
      console.log('   5. Usa testAudio.discovery() para ver peers descubiertos');

      // Configuraci√≥n de conexiones para testing
      startAutoDial(); // Usar el nuevo sistema inteligente
      startDebugging(); // Activar debug autom√°ticamente
    }

    // Funci√≥n para simular m√∫ltiples usuarios (testing)
    function simulateMultipleUsers() {
      console.log('üß™ Simulando m√∫ltiples usuarios...');
      const testUsers = ['test_user_1', 'test_user_2', 'test_user_3'];

      testUsers.forEach((userId, index) => {
        setTimeout(() => {
          console.log(`üß™ Simulando usuario: ${userId}`);
          // Simular llamada a initVoiceCall
          if (typeof initVoiceCall === 'function') {
            initVoiceCall('test_room', index + 1);
          }
        }, index * 2000); // 2 segundos entre cada usuario
      });
    }

    // Funci√≥n para stress test
    function stressTest() {
      console.log('‚ö° Iniciando stress test...');
      const maxUsers = 20;
      let currentUsers = 0;

      const addUser = () => {
        if (currentUsers < maxUsers) {
          const userId = `stress_test_${currentUsers}`;
          console.log(`‚ö° Agregando usuario ${currentUsers + 1}/${maxUsers}`);

          // Simular conexi√≥n
          callPeer(`${roomId}_${currentUsers + 1}`);
          currentUsers++;

          setTimeout(addUser, 1000); // Agregar usuario cada segundo
        } else {
          console.log('‚ö° Stress test completado');
        }
      };

      addUser();
    }

    // Funci√≥n para diagnosticar problemas de Unity
    function diagnoseUnityConnection() {
      console.log('=== DIAGN√ìSTICO DE UNITY ===');
      console.log('Unity Instance:', window.unityInstance ? '‚úÖ Disponible' : '‚ùå No disponible');

      if (window.unityInstance) {
        try {
          // Intentar encontrar objetos de Unity
          console.log('Intentando comunicar con Unity...');
          window.unityInstance.SendMessage('GestionRedJugador', 'OnVoiceReady', 'test_diagnostic');
          console.log('‚úÖ Comunicaci√≥n con Unity exitosa');
        } catch (e) {
          console.log('‚ùå Error al comunicar con Unity:', e.message);
          console.log('üí° Posibles soluciones:');
          console.log('   - Verificar que GestionRedJugador est√© en la escena');
          console.log('   - Verificar que el script est√© habilitado');
          console.log('   - Esperar a que Unity termine de cargar');
        }
      }
    }

    // Funci√≥n para diagnosticar configuraci√≥n del servidor
    function diagnoseServerConfig() {
      console.log('=== DIAGN√ìSTICO DEL SERVIDOR ===');
      console.log('Hostname:', window.location.hostname);
      console.log('Protocolo:', window.location.protocol);
      console.log('Puerto:', window.location.port);
      console.log('URL completa:', window.location.href);

      // Verificar configuraci√≥n de PeerJS
      console.log('=== CONFIGURACI√ìN PEERJS ===');
      console.log('Host PeerJS:', 'juiciosorales.site');
      console.log('Puerto PeerJS:', '443');
      console.log('Secure:', true);
      console.log('Path:', '/peerjs');

      // Verificar si hay problemas de CORS
      console.log('=== VERIFICACI√ìN CORS ===');
      if (window.location.protocol === 'https:') {
        console.log('‚úÖ HTTPS detectado - CORS deber√≠a funcionar');
      } else {
        console.log('‚ö†Ô∏è HTTP detectado - Puede haber problemas de CORS');
      }

      // Verificar WebRTC
      console.log('=== VERIFICACI√ìN WEBRTC ===');
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        console.log('‚úÖ WebRTC soportado');
      } else {
        console.log('‚ùå WebRTC no soportado');
      }

      // Verificar conectividad del servidor PeerJS
      console.log('=== VERIFICACI√ìN CONECTIVIDAD PEERJS ===');
      if (peer) {
        console.log('Estado PeerJS:', peer.disconnected ? 'Desconectado' : 'Conectado');
        console.log('ID PeerJS:', peer.id || 'No asignado');
      } else {
        console.log('‚ùå PeerJS no inicializado');
      }
    }

    // Funci√≥n para probar conectividad de todos los servidores PeerJS
    function testPeerJSServer() {
      console.log('=== PROBANDO SERVIDORES PEERJS ===');

      const testConfigs = [
        { host: 'peerjs.com', name: 'Servidor Principal' },
        { host: '0.peerjs.com', name: 'Servidor Alternativo 1' },
        { host: 'peerjs-server.herokuapp.com', name: 'Servidor Alternativo 2' }
      ];

      let testedCount = 0;
      let successCount = 0;

      testConfigs.forEach((config, index) => {
        console.log(`üîÑ Probando ${config.name} (${config.host})...`);

        const testPeer = new Peer('test_' + Date.now() + '_' + index, {
          host: config.host,
          port: 443,
          secure: true,
          path: '/peerjs',
          debug: 1
        });

        const timeout = setTimeout(() => {
          console.log(`‚è∞ Timeout en ${config.name}`);
          testPeer.destroy();
          testedCount++;
          if (testedCount === testConfigs.length) {
            console.log(`üìä Resultados: ${successCount}/${testConfigs.length} servidores funcionando`);
          }
        }, 10000);

        testPeer.on('open', (id) => {
          clearTimeout(timeout);
          console.log(`‚úÖ ${config.name} accesible - ID: ${id}`);
          successCount++;
          testPeer.destroy();
          testedCount++;
          if (testedCount === testConfigs.length) {
            console.log(`üìä Resultados: ${successCount}/${testConfigs.length} servidores funcionando`);
          }
        });

        testPeer.on('error', (err) => {
          clearTimeout(timeout);
          console.log(`‚ùå ${config.name} fall√≥: ${err.message}`);
          testPeer.destroy();
          testedCount++;
          if (testedCount === testConfigs.length) {
            console.log(`üìä Resultados: ${successCount}/${testConfigs.length} servidores funcionando`);
          }
        });
      });
    }

    // Funci√≥n para probar audio local
    function testLocalAudio() {
      console.log('=== PROBANDO AUDIO LOCAL ===');

      if (!localStream) {
        console.log('‚ùå No hay stream local disponible');
        return;
      }

      // Crear un elemento de audio para probar el stream local
      const testAudio = document.createElement('audio');
      testAudio.srcObject = localStream;
      testAudio.volume = 0.5; // Volumen bajo para testing
      testAudio.loop = true;
      testAudio.style.position = 'fixed';
      testAudio.style.top = '10px';
      testAudio.style.left = '10px';
      testAudio.style.zIndex = '10000';
      testAudio.controls = true;
      testAudio.style.background = 'white';
      testAudio.style.padding = '5px';
      testAudio.style.border = '2px solid red';

      testAudio.addEventListener('loadedmetadata', () => {
        console.log('‚úÖ Stream local cargado correctamente');
        console.log('üéµ Duraci√≥n:', testAudio.duration, 'segundos');
        console.log('üéµ Sample rate:', localStream.getAudioTracks()[0].getSettings().sampleRate);
      });

      testAudio.addEventListener('canplay', () => {
        console.log('‚úÖ Stream local listo para reproducir');
        testAudio.play().then(() => {
          console.log('üîä Reproduciendo stream local - Deber√≠as escuchar tu voz');
        }).catch(e => {
          console.error('‚ùå Error al reproducir stream local:', e);
        });
      });

      testAudio.addEventListener('error', (e) => {
        console.error('‚ùå Error en stream local:', e);
      });

      document.body.appendChild(testAudio);

      // Remover despu√©s de 10 segundos
      setTimeout(() => {
        testAudio.remove();
        console.log('üßπ Test de audio local completado');
      }, 10000);
    }

    // API global para testing
    window.testAudio = {
      // Ver estado actual
      status: () => {
        const stats = getDiscoveryStats();
        console.log('=== ESTADO DEL CHAT DE AUDIO ===');
        console.log('Mi ID:', myId);
        console.log('Room ID:', roomId);
        console.log('Conexiones activas:', stats.activeConnections);
        console.log('Peers descubiertos:', stats.discoveredPeers);
        console.log('Total descubiertos:', stats.totalDiscovered);
        console.log('Streams de audio:', document.querySelectorAll('audio').length);
        console.log('Peer conectado:', peer && !peer.disconnected);
        console.log('Latencia promedio:', latencyMeasurements.length > 0 ?
          (latencyMeasurements.reduce((a, b) => a + b, 0) / latencyMeasurements.length).toFixed(2) + 'ms' : 'N/A');
      },

      // Ver estad√≠sticas de descubrimiento
      discovery: () => {
        const stats = getDiscoveryStats();
        console.log('=== ESTAD√çSTICAS DE DESCUBRIMIENTO ===');
        console.log('Peers descubiertos:', stats.discoveredPeers);
        console.log('Conexiones activas:', stats.activeConnections);
        console.log('Total descubiertos:', stats.totalDiscovered);
        console.log('Conexiones activas:', stats.activeCount);
        return stats;
      },

      // Buscar peers espec√≠ficos
      search: searchForPeers,

      // Diagnosticar Unity
      diagnose: diagnoseUnityConnection,

      // Diagnosticar servidor
      server: diagnoseServerConfig,

      // Probar servidor PeerJS
      testServer: testPeerJSServer,

      // Probar audio local
      testAudio: testLocalAudio,

      // Limpiar todas las conexiones
      reset: resetConnections,

      // Forzar reconexi√≥n
      reconnect: () => {
        if (peer) {
          peer.destroy();
          peer = null;
        }
        currentConfigIndex = 0;
        console.log('üîÑ Reiniciando conexi√≥n PeerJS...');
        peer = tryNextPeerConfig();
        if (peer) {
          setupPeerEvents(peer);
        }
      },

      // Activar/desactivar debug
      debug: (enable = true) => {
        if (enable) startDebugging();
        else stopDebugging();
      },

      // Simular usuarios
      simulate: simulateMultipleUsers,

      // Stress test
      stress: stressTest,

      // Testing
      testing: enableTesting,

      // Control del sistema de descubrimiento
      startDiscovery: startAutoDial,
      stopDiscovery: stopAutoDial,

      // Limpiar peers descubiertos
      cleanup: cleanupDiscoveredPeers
    };

    // Configurar botones del panel de debug
    document.addEventListener('DOMContentLoaded', () => {
      const debugToggle = document.getElementById('debug-toggle');
      const debugReset = document.getElementById('debug-reset');

      if (debugToggle) {
        debugToggle.addEventListener('click', () => {
          const isVisible = document.getElementById('debug-panel').style.display !== 'none';
          if (isVisible) {
            stopDebugging();
            debugToggle.textContent = 'Mostrar';
          } else {
            startDebugging();
            debugToggle.textContent = 'Ocultar';
          }
        });
      }

      if (debugReset) {
        debugReset.addEventListener('click', resetConnections);
      }
    });

    // Activar testing autom√°ticamente
    enableTesting();
  </script>

  <script>
    // ===== SISTEMA DE LOGGING EN HTML (DEBE ESTAR PRIMERO) =====
    let debugLogEnabled = true;
    let debugLogs = [];
    const MAX_LOG_ENTRIES = 1000;
    
    // Funci√≥n para agregar log a la ventana
    function addDebugLog(level, category, message, data = null) {
      if (!debugLogEnabled) return;
      
      const timestamp = new Date().toLocaleTimeString('es-ES', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit', fractionalSecondDigits: 3 });
      const logEntry = {
        timestamp,
        level,
        category,
        message,
        data
      };
      
      debugLogs.push(logEntry);
      
      // Limitar n√∫mero de logs
      if (debugLogs.length > MAX_LOG_ENTRIES) {
        debugLogs.shift();
      }
      
      // Agregar a la ventana
      const content = document.getElementById('debug-log-content');
      if (content) {
        const entry = document.createElement('div');
        entry.className = `debug-log-entry ${level}`;
        
        let html = `<span class="timestamp">[${timestamp}]</span>`;
        html += `<span class="category">[${category}]</span>`;
        html += `<span>${escapeHtml(message)}</span>`;
        
        if (data) {
          try {
            html += `<br><span style="color: #888; margin-left: 20px;">${escapeHtml(JSON.stringify(data, null, 2))}</span>`;
          } catch (e) {
            html += `<br><span style="color: #888; margin-left: 20px;">${escapeHtml(String(data))}</span>`;
          }
        }
        
        entry.innerHTML = html;
        content.appendChild(entry);
        
        // Auto-scroll al final
        content.scrollTop = content.scrollHeight;
      }
    }
    
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
    
    function clearDebugLogs() {
      debugLogs = [];
      const content = document.getElementById('debug-log-content');
      if (content) {
        content.innerHTML = '';
      }
      addDebugLog('info', 'SYSTEM', 'Logs limpiados');
    }
    
    function toggleDebugLogWindow() {
      const window = document.getElementById('debug-log-window');
      if (window) {
        window.classList.toggle('minimized');
      }
    }
    
    function toggleDebugLogEnabled() {
      debugLogEnabled = !debugLogEnabled;
      const btn = document.getElementById('toggle-log-btn');
      if (btn) {
        btn.textContent = debugLogEnabled ? 'Desactivar' : 'Activar';
      }
      addDebugLog('info', 'SYSTEM', `Logging ${debugLogEnabled ? 'activado' : 'desactivado'}`);
    }
    
    // Interceptar console.log, console.error, console.warn
    const originalLog = console.log;
    const originalError = console.error;
    const originalWarn = console.warn;
    const originalInfo = console.info;
    
    console.log = function(...args) {
      originalLog.apply(console, args);
      const message = args.map(arg => typeof arg === 'object' ? JSON.stringify(arg) : String(arg)).join(' ');
      addDebugLog('info', 'CONSOLE', message);
    };
    
    console.error = function(...args) {
      originalError.apply(console, args);
      const message = args.map(arg => typeof arg === 'object' ? JSON.stringify(arg) : String(arg)).join(' ');
      addDebugLog('error', 'CONSOLE', message);
    };
    
    console.warn = function(...args) {
      originalWarn.apply(console, args);
      const message = args.map(arg => typeof arg === 'object' ? JSON.stringify(arg) : String(arg)).join(' ');
      addDebugLog('warning', 'CONSOLE', message);
    };
    
    console.info = function(...args) {
      originalInfo.apply(console, args);
      const message = args.map(arg => typeof arg === 'object' ? JSON.stringify(arg) : String(arg)).join(' ');
      addDebugLog('info', 'CONSOLE', message);
    };
    
    // Capturar errores globales
    window.addEventListener('error', function(e) {
      addDebugLog('error', 'GLOBAL_ERROR', `${e.message}`, {
        filename: e.filename,
        lineno: e.lineno,
        colno: e.colno,
        stack: e.error?.stack
      });
    });
    
    window.addEventListener('unhandledrejection', function(e) {
      addDebugLog('error', 'PROMISE_REJECTION', `Promise rechazada: ${e.reason}`, {
        reason: String(e.reason),
        stack: e.reason?.stack
      });
    });
    
    // Funci√≥n global para que Unity pueda llamar
    window.unityDebugLog = function(level, category, message, data) {
      addDebugLog(level || 'info', category || 'UNITY', message || '', data);
    };
    
    // Funci√≥n espec√≠fica para fases
    window.unityLogPhase = function(phaseName, status, data) {
      addDebugLog('phase', 'PHASE', `[${phaseName}] ${status}`, data);
    };
    
    // Funci√≥n espec√≠fica para API
    window.unityLogAPI = function(method, url, status, data) {
      addDebugLog('api', 'API', `[${method}] ${url} - ${status}`, data);
    };
    
    // Funci√≥n espec√≠fica para eventos
    window.unityLogEvent = function(eventName, message, data) {
      addDebugLog('event', 'EVENT', `[${eventName}] ${message}`, data);
    };
    
    // Hacer funciones disponibles globalmente
    window.addDebugLog = addDebugLog;
    window.clearDebugLogs = clearDebugLogs;
    window.toggleDebugLogWindow = toggleDebugLogWindow;
    window.toggleDebugLogEnabled = toggleDebugLogEnabled;
    
    // Log inicial
    addDebugLog('info', 'SYSTEM', 'Sistema de logging inicializado');
    addDebugLog('phase', 'INIT', 'P√°gina cargada', {
      url: window.location.href,
      userAgent: navigator.userAgent,
      timestamp: new Date().toISOString()
    });
    // ===== FIN SISTEMA DE LOGGING =====
  </script>

  <script>
    var canvas = document.querySelector("#unity-canvas");
    function unityShowBanner(msg, type) {
      var warningBanner = document.querySelector("#unity-warning");
      function update() { warningBanner.style.display = warningBanner.children.length ? 'block' : 'none' }
      var div = document.createElement('div'); div.innerHTML = msg; warningBanner.appendChild(div);
      if (type == 'error') div.style = 'background:red;padding:10px;'; else { if (type == 'warning') div.style = 'background:yellow;padding:10px;'; setTimeout(function () { warningBanner.removeChild(div); update(); }, 5000); }
      update();
    }
    // Detectar autom√°ticamente si estamos siendo servidos desde Laravel (/unity-game)
    // y ajustar las rutas base seg√∫n corresponda
    var baseUrl = "";
    var isFileProtocol = window.location.protocol === 'file:';
    
    if (window.location.pathname.includes('/unity-game')) {
      // Si estamos en /unity-game, usar /unity-build como base
      baseUrl = "/unity-build";
      console.log("üîó Detectado servidor Laravel - usando baseUrl: " + baseUrl);
    } else if (isFileProtocol) {
      // Si estamos abriendo directamente desde el sistema de archivos (file://)
      // Usar rutas relativas desde el directorio actual
      baseUrl = "./";
      console.log("üîó Modo file:// - usando rutas relativas: " + baseUrl);
      console.warn("‚ö†Ô∏è ADVERTENCIA: Abrir Unity WebGL directamente desde file:// puede causar problemas de CORS.");
      console.warn("‚ö†Ô∏è Se recomienda usar un servidor web (http://localhost:8000/unity-game)");
    } else {
      // Si estamos en desarrollo local con servidor web, usar rutas relativas
      baseUrl = "";
      console.log("üîó Modo desarrollo/local - usando rutas relativas");
    }
    
    // Detectar autom√°ticamente el nombre del build (puede ser juiciosorales, unity-build, juicio, etc.)
    // Unity puede generar diferentes nombres seg√∫n la configuraci√≥n del proyecto
    // IMPORTANTE: El nombre del build debe coincidir con el nombre del proyecto en Unity
    var buildName = "unity-build"; // Nombre por defecto (debe coincidir con el nombre del build)
    
    // Construir buildUrl de forma segura, asegurando que siempre haya un "/" entre baseUrl y "Build"
    // Esto previene rutas mal formadas como "/unity-buildBuild" o "./Build" sin separador
    var buildUrl;
    if (!baseUrl) {
      // Si baseUrl est√° vac√≠o, usar "Build" directamente
      buildUrl = "Build";
    } else if (baseUrl.endsWith("/")) {
      // Si baseUrl termina con "/", concatenar directamente
      buildUrl = baseUrl + "Build";
    } else {
      // Si baseUrl no termina con "/", agregar "/" antes de "Build"
      buildUrl = baseUrl + "/Build";
    }
    
    // Intentar detectar el nombre real del build verificando qu√© archivos existen
    // Esto se hace de forma as√≠ncrona, pero por ahora usamos nombres comunes
    // Los nombres m√°s comunes son: unity-build, juiciosorales, juicio
    var possibleNames = ["unity-build", "juiciosorales", "juicio"];
    
    // Por defecto, usar "unity-build" que es el nombre actual del proyecto
    buildName = possibleNames[0]; // Empezar con "unity-build"
    
    // Construir URLs con soporte para archivos comprimidos (.br)
    // Unity puede generar archivos con o sin compresi√≥n Brotli
    var loaderUrl = buildUrl + "/" + buildName + ".loader.js";
    var config = {
      // Intentar primero con .br (comprimido), si no existe, Unity intentar√° sin .br
      dataUrl: buildUrl + "/" + buildName + ".data.br",
      frameworkUrl: buildUrl + "/" + buildName + ".framework.js.br",
      codeUrl: buildUrl + "/" + buildName + ".wasm.br",
      streamingAssetsUrl: baseUrl ? (baseUrl.endsWith("/") ? baseUrl + "StreamingAssets" : baseUrl + "/StreamingAssets") : "StreamingAssets",
      companyName: "DefaultCompany",
      productName: "JuiciosOralesMultiplayerv1.0",
      productVersion: "0.1.0",
      showBanner: unityShowBanner
    };
    if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
      var meta = document.createElement('meta'); meta.name = 'viewport'; meta.content = 'width=device-width, height=device-height, initial-scale=1.0, user-scalable=no, shrink-to-fit=yes';
      document.getElementsByTagName('head')[0].appendChild(meta);
      document.querySelector("#unity-container").className = "unity-mobile"; canvas.className = "unity-mobile";
    } else { canvas.style.width = "960px"; canvas.style.height = "600px"; }
    document.querySelector("#unity-loading-bar").style.display = "block";
    var script = document.createElement("script"); script.src = loaderUrl;
    script.onload = () => {
      if (typeof addDebugLog === 'function') {
        addDebugLog('phase', 'UNITY', 'Loader script cargado');
      }
      createUnityInstance(canvas, config, (p) => { 
        document.querySelector("#unity-progress-bar-full").style.width = 100 * p + "%";
        if (typeof addDebugLog === 'function') {
          addDebugLog('debug', 'UNITY', `Progreso de carga: ${(p * 100).toFixed(1)}%`);
        }
      }).then((unityInstance) => {
        if (typeof addDebugLog === 'function') {
          addDebugLog('phase', 'UNITY', 'Instancia de Unity creada exitosamente');
        }
        window.unityInstance = unityInstance; 
        document.querySelector("#unity-loading-bar").style.display = "none";
        document.querySelector("#unity-fullscreen-button").onclick = () => { unityInstance.SetFullscreen(1); };
        var quit = document.createElement("button"); quit.style = "margin-left:5px;background-color:lightgray;border:none;padding:5px;cursor:pointer"; quit.innerHTML = "Unload";
        document.querySelector("#unity-build-title").appendChild(quit);
        quit.onclick = () => { unityInstance.Quit().then(() => { document.querySelector("#unity-container").remove(); canvas = null; script.remove(); script = null; }); };
      }).catch((message) => { 
        if (typeof addDebugLog === 'function') {
          addDebugLog('error', 'UNITY', `Error al crear instancia: ${message}`);
        }
        alert(message); 
      });
    };
    
    script.onerror = (error) => {
      console.error('Error al cargar el loader script:', error);
      console.error('Loader URL intentada:', loaderUrl);
      console.error('Protocolo:', window.location.protocol);
      console.error('Pathname:', window.location.pathname);
      
      if (typeof addDebugLog === 'function') {
        addDebugLog('error', 'UNITY', 'Error al cargar el loader script', {
          error: String(error),
          loaderUrl: loaderUrl,
          protocol: window.location.protocol,
          pathname: window.location.pathname,
          message: isFileProtocol 
            ? 'No puedes abrir Unity WebGL directamente desde file://. Usa un servidor web (http://localhost:8000/unity-game)'
            : 'Verifica que el archivo exista y que las rutas sean correctas'
        });
      } else {
        // Si addDebugLog no est√° disponible, mostrar alerta
        var errorMsg = isFileProtocol
          ? 'Error: No puedes abrir Unity WebGL directamente desde el sistema de archivos (file://).\n\nPor favor, usa un servidor web:\n- Laravel: http://localhost:8000/unity-game\n- O un servidor local: python -m http.server 8000'
          : 'Error al cargar Unity loader. Verifica que el archivo exista y que las rutas sean correctas.';
        alert(errorMsg);
      }
    };
    document.body.appendChild(script);
  </script>
</body>

</html>