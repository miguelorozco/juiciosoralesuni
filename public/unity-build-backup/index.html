<!DOCTYPE html>
<html lang="en-us">

<head>
  <meta charset="utf-8">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Unity Web Player | JuiciosOralesMultiplayerv1.0</title>
  <link rel="shortcut icon" href="TemplateData/favicon.ico">
  <link rel="stylesheet" href="TemplateData/style.css">
  <script src="https://unpkg.com/peerjs@1.5.5/dist/peerjs.min.js"></script>
  <style>
    .audio-status-container {
      position: absolute;
      top: 10px;
      right: 10px;
      display: flex;
      gap: 10px;
      z-index: 9999
    }

    .audio-card {
      width: 60px;
      height: 60px;
      border-radius: 10px;
      background-color: #ccc;
      display: flex;
      justify-content: center;
      align-items: center;
      transition: background-color .3s
    }

    .audio-card.active {
      background-color: #4CAF50
    }

    .audio-card img {
      width: 32px;
      height: 32px;
      filter: invert(1)
    }
  </style>
</head>

<body>
  <div class="audio-status-container">
    <div id="micCard" class="audio-card" title="Emitiendo">
      <img src="https://img.icons8.com/ios-filled/50/microphone.png" />
    </div>
    <div id="speakerCard" class="audio-card" title="Recibiendo">
      <img src="https://img.icons8.com/ios-filled/50/speaker.png" />
    </div>
  </div>

  <!-- Panel de Debug para Testing -->
  <div id="debug-panel"
    style="position: absolute; top: 80px; right: 10px; background: rgba(0,0,0,0.8); color: white; padding: 10px; border-radius: 5px; font-family: monospace; font-size: 12px; z-index: 10000; min-width: 200px; display: none;">
    <div style="font-weight: bold; margin-bottom: 5px; color: #4CAF50;">üîß DEBUG PANEL</div>
    <div>Mi ID: <span id="my-id">-</span></div>
    <div>Conexiones: <span id="connections-count">0</span></div>
    <div>Streams activos: <span id="streams-count">0</span></div>
    <div>Estado Peer: <span id="peer-status">-</span></div>
    <div>Latencia: <span id="latency">-</span></div>
    <div style="margin-top: 10px;">
      <button id="debug-toggle"
        style="background: #4CAF50; border: none; color: white; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-right: 5px;">Ocultar</button>
      <button id="debug-reset"
        style="background: #f44336; border: none; color: white; padding: 5px 10px; border-radius: 3px; cursor: pointer;">Reset</button>
    </div>
  </div>

  <div id="unity-container" class="unity-desktop">
    <canvas id="unity-canvas" width="960" height="600" tabindex="-1"></canvas>
    <div id="unity-loading-bar">
      <div id="unity-logo"></div>
      <div id="unity-progress-bar-empty">
        <div id="unity-progress-bar-full"></div>
      </div>
    </div>
    <div id="unity-warning"></div>
    <div id="unity-footer">
      <div id="unity-logo-title-footer"></div>
      <div id="unity-fullscreen-button"></div>
      <div id="unity-build-title">JuiciosOralesMultiplayerv1.0</div>
    </div>
  </div>

  <script>
    let peer = null, localStream = null, myId = null, connections = {}, roomId = null, dialInterval = null;
    const MAX_SLOTS = 20; // <- 20 espacios por sala

    async function initVoiceCall(_roomId, actorId) {
      console.log("Init Voice Call:", _roomId, actorId);
      roomId = _roomId; myId = `${roomId}_${actorId}`;
      try {
        localStream = await navigator.mediaDevices.getUserMedia({
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true,
            sampleRate: 44100,
            channelCount: 1,
            latency: 0.01
          }
        });
        activarIndicadorVolumen(localStream, document.getElementById("micCard"));
      } catch (err) { alert("No se pudo acceder al micr√≥fono."); console.error(err); return; }

      // Configuraci√≥n de servidores PeerJS con respaldo
      const peerConfigs = [
        {
          host: 'juiciosorales.site',
          port: 443,
          secure: true,
          path: '/peerjs',
          debug: 2
        },
        {
          host: 'peerjs.com',
          port: 443,
          secure: true,
          path: '/peerjs',
          debug: 2
        },
        {
          host: '0.peerjs.com',
          port: 443,
          secure: true,
          path: '/peerjs',
          debug: 2
        }
      ];

      let currentConfigIndex = 0;

      function tryNextPeerConfig() {
        if (currentConfigIndex >= peerConfigs.length) {
          console.error('‚ùå Todos los servidores PeerJS fallaron');
          return null;
        }

        const config = peerConfigs[currentConfigIndex];
        console.log(`üîÑ Intentando servidor PeerJS ${currentConfigIndex + 1}/${peerConfigs.length}:`, config.host);

        return new Peer(myId, {
          ...config,
          config: {
            iceServers: [
              { urls: 'stun:stun.l.google.com:19302' },
              { urls: 'stun:stun1.l.google.com:19302' },
              { urls: 'stun:stun2.l.google.com:19302' }
            ],
            iceTransportPolicy: 'all'
          }
        });
      }

      peer = tryNextPeerConfig();

      if (peer) {
        setupPeerEvents(peer);
      }
    }

    function setupPeerEvents(peerInstance) {
      peerInstance.on('open', id => {
        console.log("PeerJS abierto con ID:", id);

        // Funci√≥n mejorada para notificar a Unity
        const notifyUnity = () => {
          try {
            if (window.unityInstance) {
              // Intentar encontrar el objeto GestionRedJugador
              const gameObjects = unityInstance.SendMessage('FindObjectsOfType', 'GestionRedJugador');
              if (gameObjects && gameObjects.length > 0) {
                unityInstance.SendMessage('GestionRedJugador', 'OnVoiceReady', id);
                console.log("‚úÖ Notificaci√≥n enviada a Unity:", id);
                return true;
              } else {
                console.log("‚ö†Ô∏è GestionRedJugador no encontrado, reintentando...");
                return false;
              }
            }
          } catch (e) {
            console.log("‚ö†Ô∏è Error al comunicar con Unity:", e.message);
          }
          return false;
        };

        // Reintentar hasta 20 veces (10 segundos)
        let tries = 0;
        const retryInterval = setInterval(() => {
          if (notifyUnity() || ++tries > 20) {
            clearInterval(retryInterval);
            if (tries > 20) {
              console.warn("‚ö†Ô∏è No se pudo comunicar con Unity despu√©s de 20 intentos");
            }
          }
        }, 500);

        startAutoDial();
      });

      peerInstance.on('call', call => {
        console.log("üìû Llamada entrante de:", call.peer);
        addDiscoveredPeer(call.peer); // Marcar como descubierto

        call.answer(localStream);
        call.on('stream', rs => {
          console.log("‚úÖ Stream entrante de:", call.peer);
          playStream(rs, call.peer);
        });
        call.on('close', () => {
          console.log("‚ùå Llamada cerrada por:", call.peer);
          cleanupPeer(call.peer);
          discoveredPeers.delete(call.peer);
        });
        call.on('error', e => {
          console.warn('üö® Error en llamada entrante de', call.peer, ':', e);
        });
        connections[call.peer] = call;
      });

      peerInstance.on('error', err => {
        console.error('üö® Error de PeerJS:', err);

        // Si es un error de conexi√≥n al servidor, intentar con el siguiente
        if (err.message && (
          err.message.includes('Lost connection to server') ||
          err.message.includes('bad response from the server') ||
          err.message.includes('WebSocket connection') ||
          err.message.includes('Connection failed')
        )) {
          console.log('üîÑ Error de servidor detectado, intentando con el siguiente...');
          currentConfigIndex++;

          // Cerrar conexi√≥n actual
          if (peerInstance) {
            peerInstance.destroy();
          }

          // Intentar con el siguiente servidor
          setTimeout(() => {
            peer = tryNextPeerConfig();
            if (peer) {
              setupPeerEvents(peer);
            }
          }, 2000);
        } else if (err.message && err.message.includes('Could not connect')) {
          console.log('‚ÑπÔ∏è PeerJS: Conexi√≥n no disponible (normal en testing)');
        }
      });

      peerInstance.on('disconnected', () => {
        console.warn('Peer desconectado');
        // Intentar reconectar autom√°ticamente
        setTimeout(() => {
          if (currentConfigIndex < peerConfigs.length) {
            console.log('üîÑ Intentando reconectar...');
            peer = tryNextPeerConfig();
            if (peer) {
              setupPeerEvents(peer);
            }
          }
        }, 3000);
      });

      peerInstance.on('close', () => console.warn('Peer cerrado'));
    }

    function callPeer(peerId) {
      if (!peer || peerId === myId || connections[peerId]) return;

      console.log("üîä Llamando a:", peerId);
      const call = peer.call(peerId, localStream);
      if (!call) return;

      call.on('stream', rs => {
        console.log("‚úÖ Audio recibido de:", peerId);
        addDiscoveredPeer(peerId); // Marcar como descubierto
        playStream(rs, peerId);
      });

      call.on('close', () => {
        console.log("‚ùå Conexi√≥n cerrada con:", peerId);
        cleanupPeer(peerId);
        discoveredPeers.delete(peerId); // Remover de descubiertos
      });

      call.on('error', e => {
        // Solo mostrar errores importantes, no "Could not connect" que son normales
        if (!e.message || !e.message.includes('Could not connect')) {
          console.error("üö® Error en llamada con", peerId, ":", e);
        } else {
          console.log("‚ÑπÔ∏è No se pudo conectar con", peerId, "(normal si no hay usuario)");
        }
      });

      connections[peerId] = call;
    }
    window.callPeerFromUnity = callPeer;

    function cleanupPeer(peerId) {
      const c = connections[peerId];
      if (c) { try { c.close(); } catch { } delete connections[peerId]; }
      const el = document.getElementById('audio-' + peerId); if (el) el.remove();
    }

    function startAutoDial() {
      if (dialInterval) clearInterval(dialInterval);
      if (discoveryInterval) clearInterval(discoveryInterval);

      // B√∫squeda inicial
      dialRoomPeersOnce();

      // B√∫squeda peri√≥dica cada 3 segundos
      dialInterval = setInterval(dialRoomPeersOnce, 3000);

      // Limpieza de peers descubiertos cada 10 segundos
      discoveryInterval = setInterval(cleanupDiscoveredPeers, 10000);
    }

    function stopAutoDial() {
      if (dialInterval) {
        clearInterval(dialInterval);
        dialInterval = null;
      }
      if (discoveryInterval) {
        clearInterval(discoveryInterval);
        discoveryInterval = null;
      }
    }

    // Sistema inteligente de descubrimiento de usuarios
    let discoveredPeers = new Set(); // Almacenar peers descubiertos
    let discoveryInterval = null;

    function dialRoomPeersOnce() {
      if (!peer || peer.disconnected || !roomId) return;

      console.log("üîç Buscando usuarios en la sala...");

      // Solo intentar conectar con peers que sabemos que existen
      // o con un rango limitado para testing
      const maxSlots = 10; // Reducir a 10 slots m√°ximo

      for (let i = 1; i <= maxSlots; i++) {
        const pid = `${roomId}_${i}`;
        if (pid !== myId && !connections[pid] && !discoveredPeers.has(pid)) {
          // Solo intentar conectar si no hemos fallado recientemente
          callPeer(pid);
        }
      }
    }

    // Funci√≥n para agregar peer descubierto
    function addDiscoveredPeer(peerId) {
      discoveredPeers.add(peerId);
      console.log("‚úÖ Peer descubierto:", peerId);
    }

    // Funci√≥n para limpiar peers no disponibles
    function cleanupDiscoveredPeers() {
      const activePeers = new Set(Object.keys(connections));
      const toRemove = [];

      discoveredPeers.forEach(peerId => {
        if (!activePeers.has(peerId)) {
          toRemove.push(peerId);
        }
      });

      toRemove.forEach(peerId => {
        discoveredPeers.delete(peerId);
        console.log("üßπ Peer removido de descubiertos:", peerId);
      });
    }

    // Funci√≥n para obtener estad√≠sticas de descubrimiento
    function getDiscoveryStats() {
      return {
        discoveredPeers: Array.from(discoveredPeers),
        activeConnections: Object.keys(connections),
        totalDiscovered: discoveredPeers.size,
        activeCount: Object.keys(connections).length
      };
    }

    // Funci√≥n para forzar b√∫squeda de peers espec√≠ficos
    function searchForPeers(peerIds) {
      console.log("üîç B√∫squeda dirigida de peers:", peerIds);
      peerIds.forEach(peerId => {
        if (peerId !== myId && !connections[peerId]) {
          callPeer(peerId);
        }
      });
    }

    function playStream(stream, peerId) {
      let audio = document.getElementById('audio-' + peerId);
      if (!audio) {
        console.log("üéµ Creando elemento de audio para:", peerId);
        audio = document.createElement('audio');
        audio.id = 'audio-' + peerId;
        audio.autoplay = true;
        audio.playsInline = true;
        audio.style.display = 'none';
        audio.volume = 1.0; // Volumen m√°ximo
        audio.muted = false; // Asegurar que no est√© silenciado

        // Eventos para debugging
        audio.addEventListener('loadedmetadata', () => {
          console.log("‚úÖ Audio metadata cargado para:", peerId);
        });

        audio.addEventListener('canplay', () => {
          console.log("‚úÖ Audio listo para reproducir:", peerId);
          audio.play().catch(e => console.log("‚ö†Ô∏è Error al reproducir:", e));
        });

        audio.addEventListener('error', (e) => {
          console.error("‚ùå Error en audio:", peerId, e);
        });

        document.body.appendChild(audio);
      }
      audio.srcObject = stream;
      console.log("üîä Reproduciendo audio de:", peerId);
      activarIndicadorVolumen(stream, document.getElementById("speakerCard"));
    }

    function activarIndicadorVolumen(stream, cardElement) {
      const AC = window.AudioContext || window.webkitAudioContext;
      const ctx = new AC(); const src = ctx.createMediaStreamSource(stream); const an = ctx.createAnalyser();
      an.fftSize = 1024; const buf = new Uint8Array(an.frequencyBinCount); src.connect(an);
      (function upd() { an.getByteFrequencyData(buf); const v = buf.reduce((a, b) => a + b, 0) / buf.length; cardElement.classList.toggle("active", v > 10); requestAnimationFrame(upd); })();
    }

    // ===== HERRAMIENTAS DE TESTING Y DEBUGGING =====

    // Variables para debugging
    let debugInterval = null;
    let latencyMeasurements = [];

    // Funci√≥n para actualizar el panel de debug
    function updateDebugPanel() {
      const myIdElement = document.getElementById('my-id');
      const connectionsElement = document.getElementById('connections-count');
      const streamsElement = document.getElementById('streams-count');
      const peerStatusElement = document.getElementById('peer-status');
      const latencyElement = document.getElementById('latency');

      if (myIdElement) myIdElement.textContent = myId || '-';
      if (connectionsElement) connectionsElement.textContent = Object.keys(connections).length;
      if (streamsElement) streamsElement.textContent = document.querySelectorAll('audio').length;

      let peerStatus = 'No inicializado';
      if (peer) {
        if (peer.disconnected) peerStatus = 'Desconectado';
        else if (peer.open) peerStatus = 'Conectado';
        else peerStatus = 'Conectando...';
      }
      if (peerStatusElement) peerStatusElement.textContent = peerStatus;

      // Calcular latencia promedio
      if (latencyMeasurements.length > 0) {
        const avgLatency = latencyMeasurements.reduce((a, b) => a + b, 0) / latencyMeasurements.length;
        if (latencyElement) latencyElement.textContent = `${avgLatency.toFixed(0)}ms`;
      } else {
        if (latencyElement) latencyElement.textContent = '-';
      }
    }

    // Funci√≥n para medir latencia de audio
    function measureAudioLatency() {
      const audioElements = document.querySelectorAll('audio');
      let activeStreams = 0;
      let totalLatency = 0;

      audioElements.forEach(audio => {
        if (audio.srcObject) {
          activeStreams++;
          const startTime = performance.now();
          audio.addEventListener('loadeddata', () => {
            const latency = performance.now() - startTime;
            latencyMeasurements.push(latency);
            // Mantener solo las √∫ltimas 10 mediciones
            if (latencyMeasurements.length > 10) {
              latencyMeasurements.shift();
            }
          }, { once: true });
        }
      });

      if (activeStreams > 0) {
        console.log(`üìä Audio: ${activeStreams} streams activos`);
      }
    }

    // Funci√≥n para iniciar debugging
    function startDebugging() {
      const debugPanel = document.getElementById('debug-panel');
      if (debugPanel) {
        debugPanel.style.display = 'block';
        debugInterval = setInterval(() => {
          updateDebugPanel();
          measureAudioLatency();
        }, 1000);
        console.log('üîß Panel de debug activado');
      }
    }

    // Funci√≥n para detener debugging
    function stopDebugging() {
      const debugPanel = document.getElementById('debug-panel');
      if (debugPanel) {
        debugPanel.style.display = 'none';
      }
      if (debugInterval) {
        clearInterval(debugInterval);
        debugInterval = null;
      }
      console.log('üîß Panel de debug desactivado');
    }

    // Funci√≥n para resetear conexiones
    function resetConnections() {
      Object.keys(connections).forEach(peerId => {
        console.log(`üßπ Limpiando conexi√≥n: ${peerId}`);
        cleanupPeer(peerId);
      });
      latencyMeasurements = [];
      console.log('üßπ Todas las conexiones han sido limpiadas');
    }

    // Funci√≥n para testing (servidor y local)
    function enableTesting() {
      // Activar en cualquier entorno para testing
      console.log('üß™ MODO TESTING ACTIVADO');
      console.log('üìã Para testing:');
      console.log('   1. Abre esta p√°gina en 2-3 pesta√±as diferentes');
      console.log('   2. √önete a la misma sala desde cada pesta√±a');
      console.log('   3. Usa testAudio.status() en la consola para ver el estado');
      console.log('   4. Usa testAudio.diagnose() para verificar Unity');
      console.log('   5. Usa testAudio.discovery() para ver peers descubiertos');

      // Configuraci√≥n de conexiones para testing
      startAutoDial(); // Usar el nuevo sistema inteligente
      startDebugging(); // Activar debug autom√°ticamente
    }

    // Funci√≥n para simular m√∫ltiples usuarios (testing)
    function simulateMultipleUsers() {
      console.log('üß™ Simulando m√∫ltiples usuarios...');
      const testUsers = ['test_user_1', 'test_user_2', 'test_user_3'];

      testUsers.forEach((userId, index) => {
        setTimeout(() => {
          console.log(`üß™ Simulando usuario: ${userId}`);
          // Simular llamada a initVoiceCall
          if (typeof initVoiceCall === 'function') {
            initVoiceCall('test_room', index + 1);
          }
        }, index * 2000); // 2 segundos entre cada usuario
      });
    }

    // Funci√≥n para stress test
    function stressTest() {
      console.log('‚ö° Iniciando stress test...');
      const maxUsers = 20;
      let currentUsers = 0;

      const addUser = () => {
        if (currentUsers < maxUsers) {
          const userId = `stress_test_${currentUsers}`;
          console.log(`‚ö° Agregando usuario ${currentUsers + 1}/${maxUsers}`);

          // Simular conexi√≥n
          callPeer(`${roomId}_${currentUsers + 1}`);
          currentUsers++;

          setTimeout(addUser, 1000); // Agregar usuario cada segundo
        } else {
          console.log('‚ö° Stress test completado');
        }
      };

      addUser();
    }

    // Funci√≥n para diagnosticar problemas de Unity
    function diagnoseUnityConnection() {
      console.log('=== DIAGN√ìSTICO DE UNITY ===');
      console.log('Unity Instance:', window.unityInstance ? '‚úÖ Disponible' : '‚ùå No disponible');

      if (window.unityInstance) {
        try {
          // Intentar encontrar objetos de Unity
          console.log('Intentando comunicar con Unity...');
          window.unityInstance.SendMessage('GestionRedJugador', 'OnVoiceReady', 'test_diagnostic');
          console.log('‚úÖ Comunicaci√≥n con Unity exitosa');
        } catch (e) {
          console.log('‚ùå Error al comunicar con Unity:', e.message);
          console.log('üí° Posibles soluciones:');
          console.log('   - Verificar que GestionRedJugador est√© en la escena');
          console.log('   - Verificar que el script est√© habilitado');
          console.log('   - Esperar a que Unity termine de cargar');
        }
      }
    }

    // Funci√≥n para diagnosticar configuraci√≥n del servidor
    function diagnoseServerConfig() {
      console.log('=== DIAGN√ìSTICO DEL SERVIDOR ===');
      console.log('Hostname:', window.location.hostname);
      console.log('Protocolo:', window.location.protocol);
      console.log('Puerto:', window.location.port);
      console.log('URL completa:', window.location.href);

      // Verificar configuraci√≥n de PeerJS
      console.log('=== CONFIGURACI√ìN PEERJS ===');
      console.log('Host PeerJS:', 'juiciosorales.site');
      console.log('Puerto PeerJS:', '443');
      console.log('Secure:', true);
      console.log('Path:', '/peerjs');

      // Verificar si hay problemas de CORS
      console.log('=== VERIFICACI√ìN CORS ===');
      if (window.location.protocol === 'https:') {
        console.log('‚úÖ HTTPS detectado - CORS deber√≠a funcionar');
      } else {
        console.log('‚ö†Ô∏è HTTP detectado - Puede haber problemas de CORS');
      }

      // Verificar WebRTC
      console.log('=== VERIFICACI√ìN WEBRTC ===');
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        console.log('‚úÖ WebRTC soportado');
      } else {
        console.log('‚ùå WebRTC no soportado');
      }

      // Verificar conectividad del servidor PeerJS
      console.log('=== VERIFICACI√ìN CONECTIVIDAD PEERJS ===');
      if (peer) {
        console.log('Estado PeerJS:', peer.disconnected ? 'Desconectado' : 'Conectado');
        console.log('ID PeerJS:', peer.id || 'No asignado');
      } else {
        console.log('‚ùå PeerJS no inicializado');
      }
    }

    // Funci√≥n para probar conectividad de todos los servidores PeerJS
    function testPeerJSServer() {
      console.log('=== PROBANDO SERVIDORES PEERJS ===');

      const testConfigs = [
        { host: 'peerjs.com', name: 'Servidor Principal' },
        { host: '0.peerjs.com', name: 'Servidor Alternativo 1' },
        { host: 'peerjs-server.herokuapp.com', name: 'Servidor Alternativo 2' }
      ];

      let testedCount = 0;
      let successCount = 0;

      testConfigs.forEach((config, index) => {
        console.log(`üîÑ Probando ${config.name} (${config.host})...`);

        const testPeer = new Peer('test_' + Date.now() + '_' + index, {
          host: config.host,
          port: 443,
          secure: true,
          path: '/peerjs',
          debug: 1
        });

        const timeout = setTimeout(() => {
          console.log(`‚è∞ Timeout en ${config.name}`);
          testPeer.destroy();
          testedCount++;
          if (testedCount === testConfigs.length) {
            console.log(`üìä Resultados: ${successCount}/${testConfigs.length} servidores funcionando`);
          }
        }, 10000);

        testPeer.on('open', (id) => {
          clearTimeout(timeout);
          console.log(`‚úÖ ${config.name} accesible - ID: ${id}`);
          successCount++;
          testPeer.destroy();
          testedCount++;
          if (testedCount === testConfigs.length) {
            console.log(`üìä Resultados: ${successCount}/${testConfigs.length} servidores funcionando`);
          }
        });

        testPeer.on('error', (err) => {
          clearTimeout(timeout);
          console.log(`‚ùå ${config.name} fall√≥: ${err.message}`);
          testPeer.destroy();
          testedCount++;
          if (testedCount === testConfigs.length) {
            console.log(`üìä Resultados: ${successCount}/${testConfigs.length} servidores funcionando`);
          }
        });
      });
    }

    // Funci√≥n para probar audio local
    function testLocalAudio() {
      console.log('=== PROBANDO AUDIO LOCAL ===');

      if (!localStream) {
        console.log('‚ùå No hay stream local disponible');
        return;
      }

      // Crear un elemento de audio para probar el stream local
      const testAudio = document.createElement('audio');
      testAudio.srcObject = localStream;
      testAudio.volume = 0.5; // Volumen bajo para testing
      testAudio.loop = true;
      testAudio.style.position = 'fixed';
      testAudio.style.top = '10px';
      testAudio.style.left = '10px';
      testAudio.style.zIndex = '10000';
      testAudio.controls = true;
      testAudio.style.background = 'white';
      testAudio.style.padding = '5px';
      testAudio.style.border = '2px solid red';

      testAudio.addEventListener('loadedmetadata', () => {
        console.log('‚úÖ Stream local cargado correctamente');
        console.log('üéµ Duraci√≥n:', testAudio.duration, 'segundos');
        console.log('üéµ Sample rate:', localStream.getAudioTracks()[0].getSettings().sampleRate);
      });

      testAudio.addEventListener('canplay', () => {
        console.log('‚úÖ Stream local listo para reproducir');
        testAudio.play().then(() => {
          console.log('üîä Reproduciendo stream local - Deber√≠as escuchar tu voz');
        }).catch(e => {
          console.error('‚ùå Error al reproducir stream local:', e);
        });
      });

      testAudio.addEventListener('error', (e) => {
        console.error('‚ùå Error en stream local:', e);
      });

      document.body.appendChild(testAudio);

      // Remover despu√©s de 10 segundos
      setTimeout(() => {
        testAudio.remove();
        console.log('üßπ Test de audio local completado');
      }, 10000);
    }

    // API global para testing
    window.testAudio = {
      // Ver estado actual
      status: () => {
        const stats = getDiscoveryStats();
        console.log('=== ESTADO DEL CHAT DE AUDIO ===');
        console.log('Mi ID:', myId);
        console.log('Room ID:', roomId);
        console.log('Conexiones activas:', stats.activeConnections);
        console.log('Peers descubiertos:', stats.discoveredPeers);
        console.log('Total descubiertos:', stats.totalDiscovered);
        console.log('Streams de audio:', document.querySelectorAll('audio').length);
        console.log('Peer conectado:', peer && !peer.disconnected);
        console.log('Latencia promedio:', latencyMeasurements.length > 0 ?
          (latencyMeasurements.reduce((a, b) => a + b, 0) / latencyMeasurements.length).toFixed(2) + 'ms' : 'N/A');
      },

      // Ver estad√≠sticas de descubrimiento
      discovery: () => {
        const stats = getDiscoveryStats();
        console.log('=== ESTAD√çSTICAS DE DESCUBRIMIENTO ===');
        console.log('Peers descubiertos:', stats.discoveredPeers);
        console.log('Conexiones activas:', stats.activeConnections);
        console.log('Total descubiertos:', stats.totalDiscovered);
        console.log('Conexiones activas:', stats.activeCount);
        return stats;
      },

      // Buscar peers espec√≠ficos
      search: searchForPeers,

      // Diagnosticar Unity
      diagnose: diagnoseUnityConnection,

      // Diagnosticar servidor
      server: diagnoseServerConfig,

      // Probar servidor PeerJS
      testServer: testPeerJSServer,

      // Probar audio local
      testAudio: testLocalAudio,

      // Limpiar todas las conexiones
      reset: resetConnections,

      // Forzar reconexi√≥n
      reconnect: () => {
        if (peer) {
          peer.destroy();
          peer = null;
        }
        currentConfigIndex = 0;
        console.log('üîÑ Reiniciando conexi√≥n PeerJS...');
        peer = tryNextPeerConfig();
        if (peer) {
          setupPeerEvents(peer);
        }
      },

      // Activar/desactivar debug
      debug: (enable = true) => {
        if (enable) startDebugging();
        else stopDebugging();
      },

      // Simular usuarios
      simulate: simulateMultipleUsers,

      // Stress test
      stress: stressTest,

      // Testing
      testing: enableTesting,

      // Control del sistema de descubrimiento
      startDiscovery: startAutoDial,
      stopDiscovery: stopAutoDial,

      // Limpiar peers descubiertos
      cleanup: cleanupDiscoveredPeers
    };

    // Configurar botones del panel de debug
    document.addEventListener('DOMContentLoaded', () => {
      const debugToggle = document.getElementById('debug-toggle');
      const debugReset = document.getElementById('debug-reset');

      if (debugToggle) {
        debugToggle.addEventListener('click', () => {
          const isVisible = document.getElementById('debug-panel').style.display !== 'none';
          if (isVisible) {
            stopDebugging();
            debugToggle.textContent = 'Mostrar';
          } else {
            startDebugging();
            debugToggle.textContent = 'Ocultar';
          }
        });
      }

      if (debugReset) {
        debugReset.addEventListener('click', resetConnections);
      }
    });

    // Activar testing autom√°ticamente
    enableTesting();
  </script>

  <script>
    var canvas = document.querySelector("#unity-canvas");
    function unityShowBanner(msg, type) {
      var warningBanner = document.querySelector("#unity-warning");
      function update() { warningBanner.style.display = warningBanner.children.length ? 'block' : 'none' }
      var div = document.createElement('div'); div.innerHTML = msg; warningBanner.appendChild(div);
      if (type == 'error') div.style = 'background:red;padding:10px;'; else { if (type == 'warning') div.style = 'background:yellow;padding:10px;'; setTimeout(function () { warningBanner.removeChild(div); update(); }, 5000); }
      update();
    }
    var buildUrl = "Build";
    var loaderUrl = buildUrl + "/juiciosorales.loader.js";
    var config = {
      dataUrl: buildUrl + "/juiciosorales.data",
      frameworkUrl: buildUrl + "/juiciosorales.framework.js",
      codeUrl: buildUrl + "/juiciosorales.wasm",
      streamingAssetsUrl: "StreamingAssets",
      companyName: "DefaultCompany",
      productName: "JuiciosOralesMultiplayerv1.0",
      productVersion: "0.1.0",
      showBanner: unityShowBanner
    };
    if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
      var meta = document.createElement('meta'); meta.name = 'viewport'; meta.content = 'width=device-width, height=device-height, initial-scale=1.0, user-scalable=no, shrink-to-fit=yes';
      document.getElementsByTagName('head')[0].appendChild(meta);
      document.querySelector("#unity-container").className = "unity-mobile"; canvas.className = "unity-mobile";
    } else { canvas.style.width = "960px"; canvas.style.height = "600px"; }
    document.querySelector("#unity-loading-bar").style.display = "block";
    var script = document.createElement("script"); script.src = loaderUrl;
    script.onload = () => {
      createUnityInstance(canvas, config, (p) => { document.querySelector("#unity-progress-bar-full").style.width = 100 * p + "%"; }).then((unityInstance) => {
        window.unityInstance = unityInstance; document.querySelector("#unity-loading-bar").style.display = "none";
        document.querySelector("#unity-fullscreen-button").onclick = () => { unityInstance.SetFullscreen(1); };
        var quit = document.createElement("button"); quit.style = "margin-left:5px;background-color:lightgray;border:none;padding:5px;cursor:pointer"; quit.innerHTML = "Unload";
        document.querySelector("#unity-build-title").appendChild(quit);
        quit.onclick = () => { unityInstance.Quit().then(() => { document.querySelector("#unity-container").remove(); canvas = null; script.remove(); script = null; }); };
      }).catch((message) => { alert(message); });
    };
    document.body.appendChild(script);
  </script>
</body>

</html>

</html>
